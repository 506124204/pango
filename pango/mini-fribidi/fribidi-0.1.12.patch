--- /home/otaylor/ftp/fribidi-0.1.12/fribidi.c	Sat Jul 22 10:33:30 2000
+++ fribidi.c	Sun Nov 12 15:12:09 2000
@@ -17,8 +17,8 @@
  * Boston, MA 02111-1307, USA.
  */
 #include <glib.h>
-#include <stdio.h>
-#include "fribidi.h"
+#include "pango/pango-utils.h"
+#include "fribidi_types.h"
 
 /*======================================================================
 // Typedef for the run-length list.
@@ -39,47 +39,6 @@
   FriBidiChar value;
 } key_value_t;
 
-/* Global variables */
-gboolean fribidi_debug = FALSE;
-
-void fribidi_set_debug(gboolean debug)
-{
-  fribidi_debug = debug;
-}
-
-static int bidi_string_strlen(FriBidiChar *str)
-{
-  int len = 0;
-
-  while(*str++)
-    len++;
-  
-  return len;
-}
-
-static void bidi_string_reverse(FriBidiChar *str, gint len)
-{
-  int i;
-  for (i=0; i<len/2; i++)
-    {
-      FriBidiChar tmp = str[i];
-      str[i] = str[len-1-i];
-      str[len-1-i] = tmp;
-    }
-}
-
-static void
-int16_array_reverse(gint16 *arr, gint len)
-{
-  int i;
-  for (i=0; i<len/2; i++)
-    {
-      gint tmp = arr[i];
-      arr[i] = arr[len-1-i];
-      arr[len-1-i] = tmp;
-    }
-}
-
 static TypeLink *free_type_links = NULL;
 
 static TypeLink *new_type_link()
@@ -240,103 +199,6 @@
        }
 
 /*======================================================================
-//  For debugging, define some macros for printing the types and the
-//  levels.
-//----------------------------------------------------------------------*/
-static void print_types_re(TypeLink *pp)
-{
-  while(pp)
-    {
-      printf("%d:%c(%d)[%d] ", RL_POS(pp), RL_TYPE(pp), RL_LEN(pp), RL_LEVEL(pp));
-      pp = pp->next;
-    }
-  printf("\n");
-}
-
-static void print_resolved_levels(TypeLink *pp)
-{
-  while(pp)
-    {
-      int i;
-      for (i=0; i<RL_LEN(pp); i++)
-	printf("%d", RL_LEVEL(pp));
-      pp = pp->next;
-    }
-  printf("\n");
-}
-
-static void print_resolved_types(TypeLink *pp)
-{
-  while(pp)
-    {
-      int i;
-      for (i=0; i<RL_LEN(pp); i++)
-	{
-	  gchar ch;
-	  FriBidiCharType type = RL_TYPE(pp);
-         
-	  /* Convert the type to something readable */
-	  if (type == FRIBIDI_TYPE_R)
-	    ch = 'R';
-	  else if (type == FRIBIDI_TYPE_L)
-	    ch = 'L';
-	  else if (type == FRIBIDI_TYPE_E)
-	    ch = 'E';
-	  else if (type == FRIBIDI_TYPE_EN)
-	    ch = 'n';
-	  else if (type == FRIBIDI_TYPE_N)
-	    ch = 'N';
-	  else
-	    ch = '?';
-	  
-	  printf("%c", ch);
-	}
-      pp = pp->next;
-    }
-  printf("\n");
-}
-
-static void print_bidi_string(FriBidiChar *str)
-{
-  int i;
-  for (i=0; i<bidi_string_strlen(str); i++)
-    printf("%c", str[i]);
-  printf("\n");
-}
-
-/*======================================================================
-//  search_rl_for strong searches the run length list in the direction
-//  indicated by dir for a strong directional. It returns a pointer to
-//  the found character or NULL if none is found. */
-//----------------------------------------------------------------------*/
-static TypeLink *
-search_rl_for_strong(TypeLink *pos,
-		     gint  dir)
-{
-  TypeLink *pp = pos;
-
-  if (dir == -1)
-    {
-      for (pp = pos; pp; pp=pp->prev)
-	{
-	  FriBidiCharType char_type = RL_TYPE(pp);
-	  if (char_type == FRIBIDI_TYPE_R || char_type == FRIBIDI_TYPE_L)
-	    return pp;
-	}
-    }
-  else
-    {
-      for (pp = pos; pp; pp=pp->next)
-	{
-	  FriBidiCharType char_type = RL_TYPE(pp);
-	  if (char_type == FRIBIDI_TYPE_R || char_type == FRIBIDI_TYPE_L)
-	    return pp;
-	}
-    }
-  return NULL;
-}
-
-/*======================================================================
 //  This function should follow the Unicode specification closely!
 //
 //  It is still lacking the support for <RLO> and <LRO>.
@@ -360,7 +222,7 @@
   /* Determinate character types */
   char_type = g_new(gint, len);
   for (i=0; i<len; i++)
-    char_type[i] = fribidi_get_type(str[i]);
+    char_type[i] = _pango_fribidi_get_type (str[i]);
 
   /* Run length encode the character types */
   type_rl_list = run_length_encode_types(char_type, len);
@@ -511,8 +373,6 @@
   compact_list(type_rl_list);
   
   /* 5. Resolving Neutral Types */
-  if (fribidi_debug)
-      fprintf(stderr,"Resolving neutral types.\n");
 
   /* We can now collapse all separators and other neutral types to
      plain neutrals */
@@ -559,12 +419,8 @@
     }
 
   compact_list(type_rl_list);
-  if (fribidi_debug)
-      print_types_re(type_rl_list);
   
   /* 6. Resolving Implicit levels */
-  if (fribidi_debug)
-    fprintf(stderr,"Resolving implicit levels.\n");
   {
     int level = base_level;
     max_level = base_level;
@@ -605,13 +461,6 @@
   
   compact_list(type_rl_list);
 
-  if (fribidi_debug)
-    {
-      print_bidi_string(str);
-      print_resolved_levels(type_rl_list);
-      print_resolved_types(type_rl_list);
-    }
-
   *ptype_rl_list = type_rl_list;
   *pmax_level = max_level;
   *pbase_dir = base_dir;
@@ -622,160 +471,26 @@
 //----------------------------------------------------------------------*/
 
 /*======================================================================
-//  fribidi_log2vis() calls the function_analyse_string() and then
-//  does reordering and fills in the output strings.
-//----------------------------------------------------------------------*/
-void fribidi_log2vis(/* input */
-		     FriBidiChar *str,
-		     gint len,
-		     FriBidiCharType *pbase_dir,
-		     /* output */
-		     FriBidiChar *visual_str,
-		     guint16     *position_L_to_V_list,
-		     guint16     *position_V_to_L_list,
-		     guint8      *embedding_level_list
-		     )
-{
-  TypeLink *type_rl_list, *pp = NULL;
-  int max_level;
-  gboolean private_L_to_V = FALSE;
-
-  /* If v2l is to be calculated we must have l2v as well. If it is not
-     given by the caller, we have to make a private instance of it. */
-  if (position_V_to_L_list && !position_L_to_V_list)
-    {
-      private_L_to_V++;
-      position_L_to_V_list = g_new(guint16, len+1);
-    }
-
-  if (len > (2L<<16)-1)
-    {
-      fprintf(stderr, "Fribidi can't handle strings > 65000 chars!\n");
-      return;
-    }
-  fribidi_analyse_string(str, len, pbase_dir,
-			 /* output */
-			 &type_rl_list,
-			 &max_level);
-
-  /* 7. Reordering resolved levels */
-  if (fribidi_debug)
-    fprintf(stderr, "Reordering.\n");
-
-  {
-    int level_idx;
-    int i;
-
-    /* Set up the ordering array to sorted order and copy the logical
-       string to the visual */
-    if (position_L_to_V_list)
-      for (i=0; i<len+1; i++)
-	position_L_to_V_list[i]=i;
-    
-    if (visual_str)
-      for (i=0; i<len+1; i++)
-	visual_str[i] = str[i];
-
-    /* Assign the embedding level array */
-    if (embedding_level_list)
-      for (pp = type_rl_list->next; pp->next; pp = pp->next)
-	{
-	  int i;
-	  int pos = RL_POS(pp);
-	  int len = RL_LEN(pp);
-	  int level = RL_LEVEL(pp);
-	  for (i=0; i<len; i++)
-	    embedding_level_list[pos + i] = level;
-      }
-    
-    /* Reorder both the outstring and the order array*/
-    if (visual_str || position_L_to_V_list)
-      {
-
-	if (visual_str)
-	  /* Mirror all characters that are in odd levels and have mirrors */
-	  for (pp = type_rl_list->next; pp->next; pp = pp->next)
-	    {
-	      if (RL_LEVEL(pp) % 2 == 1)
-		{
-		  int i;
-		  for (i=RL_POS(pp); i<RL_POS(pp)+RL_LEN(pp); i++)
-		    {
-		      FriBidiChar mirrored_ch;
-		      if (fribidi_get_mirror_char(visual_str[i], &mirrored_ch))
-			visual_str[i] = mirrored_ch;
-		    }
-		}
-	    }
-
-	/* Reorder */
-	for (level_idx = max_level; level_idx>0; level_idx--)
-	  {
-	    for (pp = type_rl_list->next; pp->next; pp = pp->next)
-	      {
-		if (RL_LEVEL(pp) >= level_idx)
-		  {
-		    /* Find all stretches that are >= level_idx */
-		    int len = RL_LEN(pp);
-		    int pos = RL_POS(pp);
-                   TypeLink *pp1 = pp->next;
-		    while(pp1->next && RL_LEVEL(pp1) >= level_idx)
-		      {
-			len+= RL_LEN(pp1);
-			pp1 = pp1->next;
-		      }
-		    
-		    pp = pp1->prev;
-		    if (visual_str)
-		      bidi_string_reverse(visual_str+pos, len);
-		    if (position_L_to_V_list)
-		      int16_array_reverse(position_L_to_V_list+pos, len);
-
-		  }
-	      }
-	  }
-      }
-
-    /* Convert the l2v list to v2l */
-    if (position_V_to_L_list && position_L_to_V_list)
-      for (i=0; i<len; i++)
-	position_V_to_L_list[position_L_to_V_list[i]] = i;
-  }
-
-  /* Free up the rl_list */
-
-  /* At this point, pp points to the last link or (rarely) might be NULL
-   */
-  if (!pp)
-    for (pp = type_rl_list->next; pp->next; pp = pp->next)
-      /* Nothing */;
-  
-  pp->next = free_type_links;
-  free_type_links = type_rl_list;
-
-  /* Free up L_to_V if we allocated it */
-  if (private_L_to_V)
-    g_free(position_L_to_V_list);
-  
-}
-
-/*======================================================================
 //  fribidi_embedding_levels() is used in order to just get the
 //  embedding levels.
 //----------------------------------------------------------------------*/
-void fribidi_log2vis_get_embedding_levels(
+void 
+pango_log2vis_get_embedding_levels(
                      /* input */
-		     FriBidiChar *str,
+		     gunichar *str,
 		     int len,
-		     FriBidiCharType *pbase_dir,
+		     PangoDirection *pbase_dir,
 		     /* output */
 		     guint8 *embedding_level_list
 		     )
 {
   TypeLink *type_rl_list, *pp;
   int max_level;
+  FriBidiCharType fribidi_base_dir;
+
+  fribidi_base_dir = (*pbase_dir == PANGO_DIRECTION_LTR) ? FRIBIDI_TYPE_L : FRIBIDI_TYPE_R;
   
-  fribidi_analyse_string(str, len, pbase_dir,
+  fribidi_analyse_string(str, len, &fribidi_base_dir,
 			 /* output */
 			 &type_rl_list,
 			 &max_level);
@@ -793,5 +508,7 @@
   /* Free up the rl_list */
   pp->next = free_type_links;
   free_type_links = type_rl_list;
+  
+  *pbase_dir = (fribidi_base_dir == FRIBIDI_TYPE_L) ?  PANGO_DIRECTION_LTR : PANGO_DIRECTION_RTL;
 }
 
--- /home/otaylor/ftp/fribidi-0.1.12/fribidi_get_type.c	Fri May 19 05:36:54 2000
+++ fribidi_get_type.c	Sun Nov 12 14:42:56 2000
@@ -18,13 +18,14 @@
  */
 #include <stdio.h>
 #include <stdlib.h>
-#include "fribidi.h"
+#include "pango/pango-utils.h"
+#include "fribidi_types.h"
 #include "fribidi_tables.i"
 
 /*======================================================================
 //  fribidi_get_type() returns the bidi type of a character.
 //----------------------------------------------------------------------*/
-FriBidiCharType fribidi_get_type(FriBidiChar uch)
+FriBidiCharType _pango_fribidi_get_type(FriBidiChar uch)
 {
   guchar *block = FriBidiPropertyBlocks[uch / 256];
   if (block)
@@ -34,10 +35,10 @@
 }
 
 gboolean
-fribidi_get_mirror_char(/* Input */
-		       FriBidiChar ch,
-		       /* Output */
-		       FriBidiChar *mirrored_ch)
+pango_get_mirror_char(/* Input */
+		      gunichar ch,
+		      /* Output */
+		      gunichar *mirrored_ch)
 {
   int pos, step;
   gboolean found = FALSE;
--- /home/otaylor/ftp/fribidi-0.1.12/fribidi_tables.i	Fri May 19 05:12:01 2000
+++ fribidi_tables.i	Sun Nov 12 15:07:10 2000
@@ -3,8 +3,6 @@
 //  by the perl script CreateGetType.pl.
 //----------------------------------------------------------------------*/
 
-#include "fribidi.h"
-
 #define LTR FRIBIDI_TYPE_LTR
 #define RTL FRIBIDI_TYPE_RTL
 #define EN FRIBIDI_TYPE_EN
--- /home/otaylor/ftp/fribidi-0.1.12/fribidi_types.h	Fri May 19 05:07:48 2000
+++ fribidi_types.h	Sun Nov 12 14:40:58 2000
@@ -96,4 +96,6 @@
   void *attribute;
 } FriBidiRunType;
 
+FriBidiCharType _pango_fribidi_get_type(FriBidiChar uch);
+
 #endif
